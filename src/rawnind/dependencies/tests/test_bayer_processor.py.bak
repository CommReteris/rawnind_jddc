import numpy as np
import pytest
import cv2
from unittest.mock import patch, MagicMock
from rawnind.dependencies import raw_processing as raw

def test_bayer_processor_initialization():
    """
    Test BayerProcessor initialization with default config.

    Objective: Ensure BayerProcessor can be instantiated with ProcessingConfig.
    Test criteria: Instance is created without errors, has expected attributes.
    How testing fulfills purpose: Verifies basic setup of Bayer processing pipeline.
    Components mocked: None - pure instantiation test.
    Reason for hermeticity: No external dependencies in initialization.
    """
    config = raw.ProcessingConfig()
    processor = raw.BayerProcessor(config)
    assert processor is not None
    assert hasattr(processor, 'config')

def test_bayer_processor_apply_white_balance_numerical():
    """
    Test BayerProcessor.apply_white_balance applies and reverses white balance numerically.

    Objective: Verify accurate numerical application and reversal of white balance.
    Test criteria: Specific pixel values match expected values after WB and reverse WB.
    How testing fulfills purpose: Ensures WB logic is numerically correct and reversible.
    Components mocked: None - direct numpy operations.
    Reason for hermeticity: Uses controlled numerical inputs for precise validation.
    """
    config = raw.ProcessingConfig(wb_type="daylight")
    processor = raw.BayerProcessor(config)

    # Simple 2x2 mono Bayer image (representing RGGB)
    # R val, G1 val, G2 val, B val at (0,0), (0,1), (1,0), (1,1) if flattened
    initial_bayer = np.array([
        [[0.1, 0.2],
         [0.3, 0.4]]
    ], dtype=np.float32)

    # Metadata with specific daylight_whitebalance_norm, normalized by G1 (index 1)
    # The RGGB mapping in apply_white_balance: R=0, G1=1, G2=3, B=2
    # So wb_norm[0] for R, wb_norm[1] for G1, wb_norm[3] for G2, wb_norm[2] for B
    wb_norm_values = np.array([1.5, 1.0, 0.8, 1.2], dtype=np.float32) # R, G, B, G (legacy order)

    metadata = raw.Metadata(
        fpath='dummy.cr2',
        bayer_pattern=raw.BayerPattern.RGGB,
        rgbg_pattern=np.array([[0, 1], [3, 2]]), # Example pattern matching order in wb_norm
        sizes={'raw_width': 2, 'raw_height': 2},
        camera_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        black_level_per_channel=np.array([0, 0, 0, 0]),
        white_level=1,
        camera_white_level_per_channel=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance=np.array([1.5, 1.0, 1.2, 1.0]), # Raw value (R, G, B, G)
        rgb_xyz_matrix=np.eye(3),
        overexposure_lb=1.0,
        camera_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance_norm=wb_norm_values # Normalized values for apply_white_balance
    )

    # Expected values after applying white balance (initial_bayer * wb_norm_values_mapped)
    expected_r = initial_bayer[0, 0, 0] * wb_norm_values[0] # R
    expected_g1 = initial_bayer[0, 0, 1] * wb_norm_values[1] # G1
    expected_g2 = initial_bayer[0, 1, 0] * wb_norm_values[3] # G2
    expected_b = initial_bayer[0, 1, 1] * wb_norm_values[2] # B

    # Apply forward white balance
    wb_applied = processor.apply_white_balance(initial_bayer.copy(), metadata, reverse=False)

    assert np.isclose(wb_applied[0, 0, 0], expected_r)
    assert np.isclose(wb_applied[0, 0, 1], expected_g1)
    assert np.isclose(wb_applied[0, 1, 0], expected_g2)
    assert np.isclose(wb_applied[0, 1, 1], expected_b)

    # Apply reverse white balance
    wb_reversed = processor.apply_white_balance(wb_applied.copy(), metadata, reverse=True)

    # Should be back to original values approximately
    assert np.allclose(wb_reversed, initial_bayer) # Should be back to original values approximately

@patch('rawnind.dependencies.raw_processing.cv2.demosaicing')
def test_demosaic_function(mock_cv2_demosaic):
    """
    Test top-level demosaic function.

    Objective: Verify demosaic wrapper works with different methods.
    Test criteria: Calls appropriate backend, returns RGB image.
    How testing fulfills purpose: Ensures demosaic interface is functional.
    Components mocked: cv2.demosaicing to avoid OpenCV dependency in tests.
    Reason for hermeticity: OpenCV operations require compiled libraries.
    """
    mock_cv2_demosaic.return_value = np.random.rand(256, 256, 3).astype(np.float32)

    bayer_mosaic = np.random.rand(1, 256, 256).astype(np.float32)
    metadata = raw.Metadata(
        fpath='dummy.cr2',
        bayer_pattern=raw.BayerPattern.RGGB,
        rgbg_pattern=np.array([[0, 1], [1, 2]]),
        sizes={'raw_width': 256, 'raw_height': 256},
        camera_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        black_level_per_channel=np.array([0, 0, 0, 0]),
        white_level=1,
        camera_white_level_per_channel=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        rgb_xyz_matrix=np.eye(3),
        overexposure_lb=1.0,
        camera_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0])
    )

    result = raw.demosaic(bayer_mosaic, metadata)
    assert isinstance(result, np.ndarray)
    assert result.shape[0] == 3  # RGB channels (CHW format)
    mock_cv2_demosaic.assert_called_once()

def test_demosaic_integration_real_cv2():
    """
    Test demosaic function with real OpenCV (integration test).

    Objective: Verify demosaic produces valid RGB output from Bayer mosaic.
    Test criteria: Returns RGB image with correct shape, finite values, proper dynamic range.
    How testing for this criteria fulfills purpose: Ensures demosaic algorithm works correctly with real cv2.
    Components mocked: None - uses real cv2.demosaicing.
    Reason for hermeticity: Uses synthetic Bayer data, no external files.
    """
    # Create synthetic RGGB Bayer mosaic (4x4 -> 2x2 RGB after demosaic)
    # RGGB pattern: R G / G B
    bayer_mosaic = np.array([
        [0.8, 0.6, 0.7, 0.5],  # R G R G
        [0.4, 0.9, 0.3, 0.8],  # G B G B
        [0.6, 0.5, 0.8, 0.4],  # R G R G
        [0.7, 0.8, 0.6, 0.9],  # G B G B
    ], dtype=np.float32).reshape(1, 4, 4)

    metadata = raw.Metadata(
        fpath='synthetic.cr2',
        bayer_pattern=raw.BayerPattern.RGGB,
        rgbg_pattern=np.array([[0, 1], [2, 3]]),
        sizes={'raw_width': 4, 'raw_height': 4},
        camera_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        black_level_per_channel=np.array([0, 0, 0, 0]),
        white_level=1,
        camera_white_level_per_channel=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        rgb_xyz_matrix=np.eye(3),
        overexposure_lb=1.0,
        camera_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0])
    )

    # Test with default EA method
    rgb_result = raw.demosaic(bayer_mosaic, metadata)

    assert isinstance(rgb_result, np.ndarray)
    assert rgb_result.shape == (3, 4, 4)  # RGB, same spatial dims
    assert rgb_result.dtype == np.float32
    assert np.all(np.isfinite(rgb_result))
    assert 0 <= rgb_result.min() <= rgb_result.max() <= 1

    # Test with basic method
    rgb_result_basic = raw.demosaic(bayer_mosaic, metadata, method=cv2.COLOR_BayerRGGB2RGB)

    assert rgb_result_basic.shape == (3, 4, 4)
    assert rgb_result_basic.dtype == np.float32
    assert np.all(np.isfinite(rgb_result_basic))
    assert 0 <= rgb_result_basic.min() <= rgb_result_basic.max() <= 1
    # Different methods produce different results, just verify both work


def test_bayer_pattern_transformations():
    """
    Test mono_to_rggb and rggb_to_mono transformations.

    Objective: Verify Bayer pattern transformations preserve data correctly.
    Test criteria: Round-trip conversion maintains original data, correct channel ordering.
    How testing for this criteria fulfills purpose: Ensures Bayer pattern logic matches domain knowledge.
    Components mocked: None - pure numpy operations.
    Reason for hermeticity: No external dependencies, deterministic operations.
    """
    # Create test Bayer mosaic (RGGB pattern)
    mono_bayer = np.array([
        [0.8, 0.6, 0.7, 0.5],  # R G R G
        [0.4, 0.9, 0.3, 0.8],  # G B G B
        [0.6, 0.5, 0.8, 0.4],  # R G R G
        [0.7, 0.8, 0.6, 0.9],  # G B G B
    ], dtype=np.float32).reshape(1, 4, 4)

    metadata = raw.Metadata(
        fpath='test.cr2',
        bayer_pattern=raw.BayerPattern.RGGB,
        rgbg_pattern=np.array([[0, 1], [2, 3]]),
        sizes={'raw_width': 4, 'raw_height': 4},
        camera_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        black_level_per_channel=np.array([0, 0, 0, 0]),
        white_level=1,
        camera_white_level_per_channel=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
        rgb_xyz_matrix=np.eye(3),
        overexposure_lb=1.0,
        camera_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0]),
        daylight_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0])
    )

    processor = raw.BayerProcessor(raw.ProcessingConfig())

    # Convert mono to RGGB
    rggb = processor.mono_to_rggb(mono_bayer, metadata)

    assert rggb.shape == (4, 2, 2)  # 4 channels, halved spatial dims
    assert rggb.dtype == np.float32

    # Verify channel values match expected RGGB pattern
    assert rggb[0, 0, 0] == 0.8  # R at (0,0)
    assert rggb[1, 0, 0] == 0.6  # G at (0,1) -> G1
    assert rggb[2, 0, 0] == 0.4  # G at (1,0) -> G2
    assert rggb[3, 0, 0] == 0.9  # B at (1,1)

    # Convert back to mono
    mono_reconstructed = processor.rggb_to_mono(rggb)

    assert mono_reconstructed.shape == mono_bayer.shape
    assert np.allclose(mono_reconstructed, mono_bayer)
class TestExposureCheck:
    """Tests for the is_exposure_ok function."""

    @pytest.fixture
    def mock_metadata_exposure_check(self):
        """Fixture for Metadata used in exposure checks."""
        return raw.Metadata(
            fpath='dummy.cr2',
            bayer_pattern=raw.BayerPattern.RGGB,
            rgbg_pattern=raw.BAYER_PATTERNS["RGGB"],
            sizes={'raw_width': 10, 'raw_height': 10},
            camera_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
            black_level_per_channel=np.array([0, 0, 0, 0]),
            white_level=1, # This is crucial for scaling. Normalized images in [0,1].
            camera_white_level_per_channel=np.array([1.0, 1.0, 1.0, 1.0]),
            daylight_whitebalance=np.array([1.0, 1.0, 1.0, 1.0]),
            rgb_xyz_matrix=np.eye(3),
            overexposure_lb=1.0, # Assumes image is already scaled to 0-1 range based on white_level.
            camera_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0]),
            daylight_whitebalance_norm=np.array([1.0, 1.0, 1.0, 1.0])
        )

    def test_is_exposure_ok_good_exposure(self, mock_metadata_exposure_check):
        """
        Test is_exposure_ok with an image that has good exposure.

        Objective: Verify is_exposure_ok returns True for well-exposed images.
        Test criteria: No pixels exceed over/underexposure thresholds significantly.
        How testing fulfills purpose: Ensures correct identification of usable images.
        Components mocked: None, uses controlled numpy data.
        Reason for hermeticity: Isolates logic for precise validation.
        """
        # Create a mono Bayer image with values in acceptable range (e.g., 0.2 to 0.8)
        mono_img = np.full((1, 10, 10), 0.5, dtype=np.float32) # Uniformly 'grey'
        assert raw.is_exposure_ok(mono_img, mock_metadata_exposure_check) == True

    def test_is_exposure_ok_overexposed(self, mock_metadata_exposure_check):
        """
        Test is_exposure_ok with an overexposed image.

        Objective: Verify is_exposure_ok returns False for images with too much overexposure.
        Test criteria: A significant portion of pixels exceed oe_threshold.
        How testing fulfills purpose: Ensures overexposed images are correctly flagged.
        Components mocked: None, uses controlled numpy data.
        Reason for hermeticity: Isolates logic for precise validation.
        """
        mono_img = np.zeros((1, 10, 10), dtype=np.float32)
        # Set 30% of pixels to be overexposed (oe_threshold=0.99, overexposure_lb=1.0 -> >0.99)
        mono_img[:, :3, :] = 0.995 # 30 pixels overexposed out of 100
        # Default qty_threshold is 0.75, so 30% overexposure should be flagged as bad
        assert raw.is_exposure_ok(mono_img, mock_metadata_exposure_check, oe_threshold=0.99, qty_threshold=0.25) == False

    def test_is_exposure_ok_underexposed(self, mock_metadata_exposure_check):
        """
        Test is_exposure_ok with an underexposed image.

        Objective: Verify is_exposure_ok returns False for images with too much underexposure.
        Test criteria: A significant portion of pixels are below ue_threshold.
        How testing fulfills purpose: Ensures underexposed images are correctly flagged.
        Components mocked: None, uses controlled numpy data.
        Reason for hermeticity: Isolates logic for precise validation.
        """
        mono_img = np.ones((1, 10, 10), dtype=np.float32)
        # Set 30% of pixels to be underexposed (ue_threshold=0.001 -> <0.001)
        mono_img[:, :3, :] = 0.0005 # 30 pixels underexposed out of 100
        assert raw.is_exposure_ok(mono_img, mock_metadata_exposure_check, ue_threshold=0.001, qty_threshold=0.25) == False

    def test_is_exposure_ok_mix_within_threshold(self, mock_metadata_exposure_check):
        """
        Test is_exposure_ok with mixed over/underexposure within quantity threshold.

        Objective: Verify is_exposure_ok returns True when total problematic pixels are acceptable.
        Test criteria: Combined over/underexposed pixels are below qty_threshold.
        How testing fulfills purpose: Ensures threshold logic is correctly applied for mixed conditions.
        Components mocked: None, uses controlled numpy data.
        Reason for hermeticity: Isolates logic for precise validation.
        """
        mono_img = np.full((1, 10, 10), 0.5, dtype=np.float32)
        # 10% overexposed, 10% underexposed. Total 20% problematic.
        # With default qty_threshold=0.75, this should pass.
        mono_img[:, :1, :] = 0.995  # Overexposed band
        mono_img[:, 1:2, :] = 0.0005 # Underexposed band
        assert raw.is_exposure_ok(mono_img, mock_metadata_exposure_check) == True

    def test_is_exposure_ok_mix_exceeding_threshold(self, mock_metadata_exposure_check):
        """
        Test is_exposure_ok with mixed over/underexposure exceeding quantity threshold.

        Objective: Verify is_exposure_ok returns False when total problematic pixels are too high.
        Test criteria: Combined over/underexposed pixels exceed qty_threshold.
        How testing fulfills purpose: Ensures threshold logic correctly flags problematic images.
        Components mocked: None, uses controlled numpy data.
        Reason for hermeticity: Isolates logic for precise validation.
        """
        mono_img = np.full((1, 10, 10), 0.5, dtype=np.float32)
        # 30% overexposed, 30% underexposed. Total 60% problematic.
        # With qty_threshold=0.5, this should fail.
        mono_img[:, :3, :] = 0.995  # Overexposed band
        mono_img[:, 3:6, :] = 0.0005 # Underexposed band
        assert raw.is_exposure_ok(mono_img, mock_metadata_exposure_check, qty_threshold=0.5) == False